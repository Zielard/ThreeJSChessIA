<!--------------------------------------------------------------------------------
	
	Aplikacja three.js - 06 swiatlo (swiatlo porusza sie relatywnie w stosunku do obiektu)
		Poniewaz Three.js ma spojrzenie z punktu widzenia obiektu wiec aby dokonac obrotu do okola osi
		w pierwszej kolejnosci nalezy stworzyc obiekty ktore juz sa przesuniete
		takie obiekty dodajemy do grupy i teraz gdy obracamy grupe to obiekty obracaja sie po okregu wokol srodka grupy
	
	P.Kowalczyk styczen 2018
	Na podstawie 
	https://threejs.org/docs/index.html#manual/introduction/Creating-a-scene

Zmiany:
wersja orginalna							P.K. 01/01/2018
dodana manipulacja swiatlem przez wheel     P.K. 20/10/2018

-------------------------------------------------------------------------------->

<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>ChessIA</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/Board.js">//biblioteka do kontroli widoku</script>
		<script src='js/StartPack.js'>//biblioteka do pustej sceny</script>
		<script src="js/OBJLoader.js">//wczytywanie pilku obj</script>
		<script src="js/MTLLoader.js">//wczytanie dodatkowego pliku materialow do obj</script>
		<script src="js/OrbitControls.js">//biblioteka do kontroli widoku</script>
		<script>

			//FOR RAYCST!!!//////////////////////////////////////////////////////////
			var raycaster;
			raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2(), INTERSECTED;
			var oldPlanePos;
			var mustMoveColor = "w";
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}

			document.addEventListener('click', event => {
			if(lastSelectRay != null)
			{
				if(raycastOn == true)
				{
					findPawn();
					raycastOn = !raycastOn;
				}
				else
				{
					oldPlanePos = lastSelectRay;
					for(let i =0;i<activePlans.length;i++)
					{
						activePlans[i].object.material.emissive.setHex( 0x000000 );
					}
					raycastOn = !raycastOn;
				}
			}
			});
			/////////////////////////////////////////////////////////////////////////
			var deletePawnBlack = [];
			var deletePawnWhite = [];
			var activePlans = [];
			var lastSelectRay = null;
			var oldColorPawn;
			var raycastOn = true;
			//Grupa zawirajaca wszystkie obiekty zamiast pionkow
			var group = new THREE.Group();
			group.position.x = -2.5;
			group.position.z = -2.5;
			//Grupa zawirajaca wszystkie obiekty na scenie
			var pawnsGroup = new THREE.Group();
			var lightPos = 1;

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			camera.position.y =35;

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			//camera.lookAt(camera.position.x-2.5, 0 ,camera.position.z-2.5);
			renderer.setClearColor( 0xffffff, 1 );

			//Szachownica
			var board;
			//Ladowanie pionkow
			StartPack.loadBaseObj();

            ////////////////////////////
            //Utworzenie kontrolera dzieki ktoremu mozna myszka zmieniac polozenie kamery na scenie
            //
			var Orbit = new THREE.OrbitControls( camera, renderer.domElement );
			Orbit.update();
			Orbit.enablePan = false;
		
			//dla swiatla i jego wizualizacji tworzymy jeszcze jedna grupe
			//dzieki temu bedzie nam latwo przesuwac cala grupe a nie osobno swiatlo i 
			//osobno kulke symbolizujaca jego lokalizacje w przestrzeni
			var groupLight = new THREE.Group();
			
			//tworzymy swiatlo ambient
			var ambientLight = new THREE.AmbientLight( 0x404040 );
			scene.add(ambientLight);
			
			//tworzymy swiatlo punktowe
			var light = new THREE.PointLight( 0xffffff, 1, 100 );
			light.position.set( 0, 15, 0 );
			groupLight.add( light );

			            ///////////////////////////////////////
            //cubemap / skybox
            //
			var path = "szachy.low.poly/textura/greenland/"; 
            var format = '.jpg';
			var urls = [ path + "px.jpg", path + "nx.jpg",
					path + "py.jpg", path + "ny.jpg",
					path + "pz.jpg", path + "nz.jpg"];
					
			//odbicia
            var reflectionCube = new THREE.CubeTextureLoader().load( urls );
            reflectionCube.format = THREE.RGBFormat;
            //scene.background = reflectionCube;

			//przezroczysto&#65533;ci
			refractionCube = new THREE.CubeTextureLoader().load( urls );
			refractionCube.mapping = THREE.CubeRefractionMapping;
			refractionCube.format = THREE.RGBFormat;

			//console.log(refractionCube);
			//scene.background = reflectionCube;
			// //tworzymy sfere w miejscu gdzie jest swiatlo
			// var sphere = new THREE.SphereGeometry( 0.1, 10, 10);
			// var smesh = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial({ color: 0xff8000 }) );
			// smesh.position.copy( light.position );	
			// groupLight.add(smesh);
			
		
			//dodajemy swiatlo i kulke do grupy ktora bedzie zawierala jeszcze kostke
			group.add(groupLight);
			
			//dodajemy grupe do sceny
			scene.add(group);
			scene.add(pawnsGroup);
			var animate = function () {
				requestAnimationFrame( animate );
				renderer.render(scene, camera);
				if(raycastOn == true)
				{
					raycast();
				}

		};

			animate();
			function raycast()
			{
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( scene.children , true );
					if ( intersects.length > 0 ) {


								if ( INTERSECTED != intersects[ 0 ].object.parent ) {
								if(lastSelectRay == null)
								{
								INTERSECTED = intersects[ 0 ].object;
								INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
								INTERSECTED.material.emissive.setHex( 0xff0000 );
								lastSelectRay = intersects[ 0 ].object;
								oldPlanePos = intersects[ 0 ].object;
								}
								if(lastSelectRay != intersects[ 0 ].object)
								{
									// 	console.log("Change");
									// for(let i =0;i<8;i++)
									// {
									// 	for(let j =0;j<8;j++)
									// 	{
									// 		console.log(board.BoardTable[i][j]);
									// 	}
									// }
										lastSelectRay.material.emissive.setHex( 0x000000 );
										INTERSECTED = intersects[ 0 ].object;
										INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
										INTERSECTED.material.emissive.setHex( 0xff0000 );
										lastSelectRay = intersects[ 0 ].object;

										for(let i =0;i<activePlans.length;i++)
										{
											if(activePlans[i].object == lastSelectRay)
											{
												changePawnPosition();
											}
										}
										activePlans = [];
								}
							}
						else
						{
							lastSelectRay = null;
						}
					} else {
						lastSelectRay = null;
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( 0x000000);
						INTERSECTED = null;
					}
			}	
			function findPawn()
			{
				for(let i =0;i<8;i++)
				{
					for(let j =0;j<8;j++)
					{
						if(board.BoardTable[i][j].figure != null)
						{				
							if(board.BoardTable[i][j].figure.object == lastSelectRay)
							{
								if(mustMoveColor == board.BoardTable[i][j].figure.color)
								{
									board.BoardTable[i][j].figure.showMove(i,j);
								}
								i = 7;
								j = 7;
							}
						}
					}
				}
			}
			function changePawnPosition()
			{
				console.log("True change");
				let find_pawn = false;
				let find_plane = false;
				var pawnIndex = new THREE.Vector2( 0, 0 );
				var planeIndex = new THREE.Vector2( 0, 0 );
				for(let i =0;i<8;i++)
				{
					for(let j =0;j<8;j++)
					{
						if(board.BoardTable[i][j].figure != null)
						{
							if(board.BoardTable[i][j].figure.object == oldPlanePos)
							{
								pawnIndex.x = i;
								pawnIndex.y = j;
								find_pawn = true;
							}
						}	
						if(board.BoardTable[i][j].object == lastSelectRay)
						{
							planeIndex.x = i;
							planeIndex.y = j;
							find_plane = true;
						}
						if((find_pawn && find_plane) == true)
						{
							if(board.BoardTable[planeIndex.x][planeIndex.y].figure != null)
							{
								if(board.BoardTable[planeIndex.x][planeIndex.y].figure.color == "b")
								{
									deletePawnBlack.push(board.BoardTable[planeIndex.x][planeIndex.y].figure.object);
									board.BoardTable[planeIndex.x][planeIndex.y].figure = null;
									sortFigureBlack();
								}
								else if(board.BoardTable[planeIndex.x][planeIndex.y].figure.color == "w")
								{
									deletePawnWhite.push(board.BoardTable[planeIndex.x][planeIndex.y].figure.object);
									board.BoardTable[planeIndex.x][planeIndex.y].figure = null;
									sortFigureWhite();
								}
							}
							
							let temp_state = board.BoardTable[pawnIndex.x][pawnIndex.y].stateNumber;
							board.BoardTable[pawnIndex.x][pawnIndex.y].stateNumber = board.BoardTable[planeIndex.x][planeIndex.y].stateNumber;
							board.BoardTable[planeIndex.x][planeIndex.y].stateNumber = temp_state;
							board.BoardTable[planeIndex.x][planeIndex.y].figure = board.BoardTable[pawnIndex.x][pawnIndex.y].figure;
							board.BoardTable[pawnIndex.x][pawnIndex.y].figure = null;

							oldPlanePos.position.x = board.BoardTable[planeIndex.x][planeIndex.y].position.x;
							oldPlanePos.position.y = board.BoardTable[planeIndex.x][planeIndex.y].position.y;
							oldPlanePos.position.z = board.BoardTable[planeIndex.x][planeIndex.y].position.z;
							if(mustMoveColor == "w")
							{
								mustMoveColor = "b";
							}
							else if(mustMoveColor == "b")
							{
								mustMoveColor = "w";
							}
							else
							{
								console.log("Change color error invalid color in fun");
							}
						i = 7;
						j = 7;
						}
					}
				}
			}	
			function sortFigureBlack()
			{
					for(let i=0;i<deletePawnBlack.length;i++)
					{
						deletePawnBlack[i].position.x = 22.5;
					    deletePawnBlack[i].position.z = i*2.5;
					}
			}
			function sortFigureWhite()
			{
				for(let i=0;i<deletePawnWhite.length;i++)
					{
						deletePawnWhite[i].position.x = -22.5;
					    deletePawnWhite[i].position.z = i*2.5;
					}
			}
		</script>
	</body>
</html>